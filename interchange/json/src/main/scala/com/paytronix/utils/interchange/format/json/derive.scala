//
// Copyright 2014-2020 Paytronix Systems, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package com.paytronix.utils.interchange.format.json

import scala.annotation.StaticAnnotation
import scala.language.experimental.macros

/**
 * Annotations and macros to derive coders automatically at compile time.
 *
 * Intended to be used qualified, e.g. @derive.structure.implicitCoder.
 */
object derive {
    object structure {
        /**
         * Automatically generate an `JsonCoder` for a structural type.
         *
         * For example:
         *
         *     @derive.structure.implicitCoder
         *     final case class MyStruct(a: Int, b: String)
         *
         * Will put an implicit coder on the companion object of `MyStruct` creating that companion object if it doesn't exist already,
         * like:
         *
         *     object MyStruct {
         *         implicit val jsonCoder = derive.structure.coder[MyStruct]
         *     }
         *     final case class MyStruct(a: Int, b: String)
         */
        /* 2014-08-27 RMM: having multiple annotation macros which addToCompanion causes the compiler to not emit the object class (Blah$) even though
                           it doesn't error at runtime.
        class implicitCoder extends StaticAnnotation {
            def macroTransform(annottees: Any*): Any = macro deriveImpl.deriveImplicitStructureCoderAnnotation
        }
        */

        /**
         * Make the annotated class or object a complete `JsonCoder` for the given type allowing for individual field codings to be altered.
         *
         * For example:
         *
         *     final case class MyStruct(a: BigDecimal, b: String)
         *     object MyStruct {
         *         @derive.structure.customizedCoder[MyStruct]
         *         implicit object jsonCoder {
         *             val a = doubleCoder.mapBijection(bijection (
         *                 (bd: BigDecimal) => Okay(bd.doubleValue),
         *                 (d: Double) => Okay(BigDecimal(d))
         *             ))
         *         }
         *     }
         *
         * will create a coder identical to the one generated by `derive.structure.coder` or `@derive.structure.implicitCoder` but with the
         * coder used for the field `a` overridden from the default.
         */
        class customizedCoder[A] extends StaticAnnotation {
            def macroTransform(annottees: Any*): Any = macro deriveImpl.structureCoderAnnotation
        }

        /**
         * Make the annotated class or object a complete `JsonEncoder` for the given type allowing for individual field encodings to be altered.
         * See `customizedCoder` for an example.
         */
        class customizedEncoder[A] extends StaticAnnotation {
            def macroTransform(annottees: Any*): Any = macro deriveImpl.structureEncoderAnnotation
        }

        /**
         * Make the annotated class or object a complete `JsonDecoder` for the given type allowing for individual field decodings to be altered.
         * See `customizedCoder` for an example.
         */
        class customizedDecoder[A] extends StaticAnnotation {
            def macroTransform(annottees: Any*): Any = macro deriveImpl.structureDecoderAnnotation
        }

        /**
         * Generate an `JsonCoder` for the given type, using coders from the implicit scope for field codings.
         * Fails at compile time if a coding can't be determined for a field.
         */
        def coder[A]: JsonCoder[A] = macro deriveImpl.structureCoderDef[A]

        /**
         * Generate an `JsonEncoder` for the given type, using encoders from the implicit scope for field encodings.
         * Fails at compile time if a encoding can't be determined for a field.
         */
        def encoder[A]: JsonEncoder[A] = macro deriveImpl.structureEncoderDef[A]

        /**
         * Generate an `JsonDecoder` for the given type, using decoders from the implicit scope for field decodings.
         * Fails at compile time if a decoding can't be determined for a field.
         */
        def decoder[A]: JsonDecoder[A] = macro deriveImpl.structureDecoderDef[A]
    }

    /**
     * Annotation and macros to derive coding for wrapper types - types with a single field which wrap some other type and are represented when
     * encoded as that other type. Sometimes this is called a newtype, sometimes a value type, but for the purposes of encoding and decoding any
     * class with a single field counts.
     *
     * For example:
     *
     *     @derive.wrapper.implicitCoder
     *     final case class Meters(m: Int) extends AnyVal
     *
     * In this example, a value of type `Meters` would be encoded as an integer, but is a distinct type in Scala.
     */
    object wrapper {
        /* 2014-08-27 RMM: having multiple annotation macros which addToCompanion causes the compiler to not emit the object class (Blah$) even though
                           it doesn't error at runtime.
        class implicitCoder extends StaticAnnotation {
            def macroTransform(annottees: Any*): Any = macro deriveImpl.deriveImplicitWrapperCoderAnnotation
        }
        */

        /**
         * Generate an `JsonCoder` for the given wrapping type, using a coder from the implicit scope for the single field decoding.
         * Fails at compile time if a decoding can't be determined.
         */
        def coder[A]: JsonCoder[A] = macro deriveImpl.wrapperCoderDef[A]

        /**
         * Generate an `JsonEncoder` for the given wrapping type, using an encoder from the implicit scope for the single field encoding.
         * Fails at compile time if a decoding can't be determined.
         */
        def encoder[A]: JsonEncoder[A] = macro deriveImpl.wrapperEncoderDef[A]

        /**
         * Generate an `JsonDecoder` for the given wrapping type, using a decoder from the implicit scope for the single field decoding.
         * Fails at compile time if a decoding can't be determined.
         */
        def decoder[A]: JsonDecoder[A] = macro deriveImpl.wrapperDecoderDef[A]
    }

    /** Annotation and macro to derive union (sum type) coders that use an explicit intensional field to discriminate among alternates. */
    object taggedUnion {
        /**
         * Automatically generate an `JsonCoder` for a union type whose alternates have been enumerated with
         * a `com.paytronix.utils.interchange.base.union` annotation.
         *
         * For example:
         *
         *     @derive.taggedUnion.implicitCoder("type")
         *     @union(union.alt[First].tag("first"), union.alt[Second].tag("second"))
         *     sealed abstract class MyUnion
         *     final case class First extends MyUnion
         *     final case class Second extends MyUnion
         *
         * Will put an implicit coder on the companion object of `MyUnion` creating that companion object if it doesn't exist already,
         * like:
         *
         *     object MyUnion {
         *         implicit val jsonCoder = derive.taggedUnion.coder("type", union.alt[First].tag("first"), union.alt[Second].tag("second"))
         *     }
         *     sealed abstract class MyUnion
         *     final case class First extends MyUnion
         *     final case class Second extends MyUnion
         */
        /* 2014-08-27 RMM: having multiple annotation macros which addToCompanion causes the compiler to not emit the object class (Blah$) even though
                           it doesn't error at runtime.
        class implicitCoder(determinant: String) extends StaticAnnotation {
            def macroTransform(annottees: Any*): Any = macro deriveImpl.deriveImplicitTaggedUnionCoderAnnotation
        }
        */

        private[taggedUnion] sealed trait Alternate[A]

        /** Declare a single alternate of a union. Intended only for use as syntax in a @derive.taggedUnion.* annotation */
        def alternate[A](tag: String): Alternate[A] = new Alternate[A] { }

        /**
         * Derive an `JsonCoder` for a union (sum type), given explicitly named subtypes as alternates. The alternates should be tagged,
         * but if they are not a tag based on the type name will be used.
         */
        def coder[A](determinant: String, alternates: Alternate[_ <: A]*): JsonCoder[A] = macro deriveImpl.taggedUnionCoderDef[A]

        /**
         * Derive an `JsonEncoder` for a union (sum type), given explicitly named subtypes as alternates. The alternates should be tagged,
         * but if they are not a tag based on the type name will be used.
         */
        def encoder[A](determinant: String, alternates: Alternate[_ <: A]*): JsonEncoder[A] = macro deriveImpl.taggedUnionEncoderDef[A]

        /**
         * Derive an `JsonDecoder` for a union (sum type), given explicitly named subtypes as alternates. The alternates should be tagged,
         * but if they are not a tag based on the type name will be used.
         */
        def decoder[A](determinant: String, alternates: Alternate[_ <: A]*): JsonDecoder[A] = macro deriveImpl.taggedUnionDecoderDef[A]
    }

    /** Annotation and macro to derive union (sum type) coders that assume the various alternates follow distinct formats and tries each format in turn. */
    object adHocUnion {
        /**
         * Automatically generate an `JsonCoder` for a union type whose alternates have been enumerated with
         * a `com.paytronix.utils.interchange.base.union` annotation.
         *
         * For example:
         *
         *     @derive.adHocUnion.implicitCoder("expected First or Second")
         *     @union(union.alt[First], union.alt[Second])
         *     sealed abstract class MyUnion
         *     final case class First extends MyUnion
         *     final case class Second extends MyUnion
         *
         * Will put an implicit coder on the companion object of `MyUnion` creating that companion object if it doesn't exist already,
         * like:
         *
         *     object MyUnion {
         *         implicit val jsonCoder = derive.adHocUnion.coder("expected First or Second", union.alt[First], union.alt[Second])
         *     }
         *     sealed abstract class MyUnion
         *     final case class First extends MyUnion
         *     final case class Second extends MyUnion
         *
         * <strong>NOTE:</strong> take care with the order of union alternates since it will try each in turn so if one is a subset of the other
         * then the wrong one might be picked.
         */
        /* 2014-08-27 RMM: having multiple annotation macros which addToCompanion causes the compiler to not emit the object class (Blah$) even though
                           it doesn't error at runtime.
        class implicitCoder(noApplicableAlternates: String) extends StaticAnnotation {
            def macroTransform(annottees: Any*): Any = macro deriveImpl.deriveImplicitAdHocUnionCoderAnnotation
        }
        */

        private[adHocUnion] sealed trait Alternate[A]

        /** Declare a single alternate of a union. Intended only for use as syntax in a @derive.adHocUnion.* annotation */
        def alternate[A]: Alternate[A] = new Alternate[A] { }

        /**
         * Derive an `JsonCoder` for a union (sum type), given explicitly named subtypes as alternates. The alternates may be tagged,
         * but the tag will be ignored as this type of union just tries each alternate in turn.
         */
        def coder[A](noApplicableAlternates: String, alternates: Alternate[_ <: A]*): JsonCoder[A] = macro deriveImpl.adHocUnionCoderDef[A]

        /**
         * Derive an `JsonEncoder` for a union (sum type), given explicitly named subtypes as alternates. The alternates may be tagged,
         * but the tag will be ignored as this type of union just tries each alternate in turn.
         */
        def encoder[A](noApplicableAlternates: String, alternates: Alternate[_ <: A]*): JsonEncoder[A] = macro deriveImpl.adHocUnionEncoderDef[A]

        /**
         * Derive an `JsonDecoder` for a union (sum type), given explicitly named subtypes as alternates. The alternates may be tagged,
         * but the tag will be ignored as this type of union just tries each alternate in turn.
         */
        def decoder[A](noApplicableAlternates: String, alternates: Alternate[_ <: A]*): JsonDecoder[A] = macro deriveImpl.adHocUnionDecoderDef[A]
    }
}
